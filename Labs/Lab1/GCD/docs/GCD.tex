\section{Designing a Greatest Common Divisor Circuit}
\subsection{Theory}
Greatest Common Divisor (GCD) of two non zero integers is the largest number that is a common divisor of both integers. In this implementation, we are more focused on circuit size and speed rather than optimizing the algorithm. The common way of computing the GCD can be accomplished by the following algorithm:

\begin{algorithm}
\caption{Computing GCD algorithm}\label{euclid gcd}
\begin{algorithmic}[1]
\Procedure{GCD(A, B)}{}
\BState \emph{begin}:
\If {(A==B)} \textbf{goto} \emph{end}
\EndIf
\If {(A>B)} $\textit A \gets A-B$
\EndIf
\If {(B<A)} $\textit B \gets B-A$
\EndIf
\State \textbf{goto} \emph{begin}
\BState \emph{end}:
\State $\textit return \ A$
\EndProcedure
\end{algorithmic}
\end{algorithm}

The algorithm subtracts the largest number between the two inputs, from the other one. It will then update the largest input by the result of subtraction. This procedure will be continued until the two numbers are equal. This algorithm can be recursively implemented in System-Verilog as follows:


\begin{minted}{verilog}
function int gcd_fcn(int a, int b);
    return b == 0 ? a : gcd_fcn(b, a % b);
endfunction
\end{minted}

\subsection{Implementation}
The behavioral model presented in previous section cannot be implemented in hardware. For that we need to extract the essential computational blocks from the algorithm. We are also going to need a state machine to keep track of states we are in. The state machine should also compute the next state. Adding state machine would increase our design size. This is due to the gate level implementation of registers that are required by the state machine to hold values between clock cycles. This means that one of the best ways of reducing the design size is to reduce the number of states that we need. In the first implementation of GCD, we used 3 states to compute the GCD. The following listing shows only the combinational logic part (the source code for this implementation can be found in \href{https://github.com/hossein1387/random_hw_experiments/blob/master/GCD/GCDopt.sv}{link to GCD repository}):

\begin{minted}{verilog}
    case (state)
      s0: begin
            a_next      = a_in;
            b_next      = b_in;
            gcd         = 32'd0;
            state_next  = s1; 
            done        = 0;
        end
      s1: begin
        if(a!=b) begin
            a_next= (a >= b) ? a - b : a;
            b_next     = (b >  a) ? b - a : b;
            gcd        = 32'd0;
            state_next = s1;
        end else begin
            state_next = s2;
            end
        end
      s2: begin
            gcd = a;
            state_next = s0;
            done = 1;
        end
        default: begin
            state_next = s0;
        end
    endcase
\end{minted}

In the code above, \mintinline{latex}{s0} samples the input and pulls down the $done$ signal (that indicates the output is ready to be sampled). In \mintinline{latex}{s1}, we subtract the largest number from the other one and update the next state. Finally \mintinline{latex}{s2} changes the next state to \mintinline{latex}{s0} and more importantly, pulls up the ``done'' signal and outputs the result on the output line. Figure \ref{SCHEMATIC} shows the schematic view of the circuit:

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Images/schematic.png}
    \caption{High level Schematic view of GCD implementation showing combinational and sequential logic }
    \label{SCHEMATIC}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Images/GCDNormal.png}
    \caption{GCD optimized}
    \label{GCDNORMAL}
\end{figure}

Figure \ref{GCDNORMAL} shows the waveform generated by GTKWave. As it is illustrated, GCD 14 and 161 is computed after 12 clock cycles and after that the ``done'' signal stays high for one clock cycle. As described earlier, by reducing number of states in the state machine, we can reduce the circuit size.  

To reduce the number of states, we can combine states 1 and 2 so that only 1 bit is required to hold the state and we will end up with less number of registers. The following listing shows how this can be achieved:
\begin{minted}{verilog}
    case (state)
      s0: begin
            a_next      = a_in;
            b_next      = b_in;
            gcd         = 32'd0;
            state_next  = s1; 
            done        = 0;
        end
      s1: begin
        if(a!=b) begin
            a_next= (a >= b) ? a - b : a;
            b_next     = (b >  a) ? b - a : b;
            gcd        = 32'd0;
            state_next = s1;
        end else begin
            gcd = a;
            state_next = s0;
            done = 1;
            end
        end
        default: begin
            state_next = s0;
        end
\end{minted}

Figure \ref{GCDOPT} shows that the same result is achieved but with less number of registers. The synthesis of this circuit is done using Yosys 3.0 available at 
\href{https://www.edaplayground.com/x/4reN}{Synthesis Result}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Images/GCDOpt.png}
    \caption{GCD optimized}
    \label{GCDOPT}
\end{figure}

\subsection{Results and Source Code}

\markdownInput{GCD.md}
